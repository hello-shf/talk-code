## java并发编程实践

#### [01 | 可见性、原子性和有序性问题：并发编程Bug的源头](https://time.geekbang.org/column/article/83682)

> 笔记

* 并发编程的三个问题
    * 原子性 -> 一个操作是不可中断的，要么全部执行成功要么全部执行失败。
        * 指令级别语义：CPU单个指令一定是原子性的。
        * java语言语义：java中一个指令不代表是具备原子性的。java指令是对CPU指令的封装。（1 - n）
    * 有序性 -> 程序按照代码顺序有序执行
        * 编译期优化：在java编译期，JVM认为改变指令顺序不会影响结果的场景中（不违反happens-before），会进行编译期的指令重排
        * CPU指令重排：为了解决MESI协议导致的CPU空闲，引入了指令重排机制。大大提高了CPU的利用率
    * 可见性 -> 当前线程对共享变量的修改，对其它线程立即可见
        * JMM语义：在JMM中线程对共享变量的修改对其它线程立即可见。
        * CPU语义：一个内核对L1/l2缓存的M(modify)操作对其它S(share)该变量的内核可见。
            * 可见性问题的根本来源：指令重排导致的CPU指令乱序执行。最终根源
                * Store Buffere
                * Invalidte Queue

> 金句

**在采用一项技术的同时，一定要清楚它带来的问题是什么，以及如何规避**

举个例子，我们为了对系统实施监控，会引入例如pinpoint之类的AMP组件，解决了监控问题
的同时也带来了性能问题，比如对带宽的占用，增加了接口响应的延时等；再比如，微服务
架构是为了解决单体应用灵活性差等问题而出现，同时也带了了架构的复杂度，增加了服务
之间通信，数据隔离等问题。所以，一个技术在解决某个问题的同时可能带来新的问题，这样
我们可能又会为新的问题引入别的技术来处理，这是个不断循环的过程。因此，我们在评估
一项技术的时候，需要充分考虑其负面影响，怎么权衡利弊，实现利益最大化。
CPU --> 三级缓存 --> MESI协议 --> 指令重排

#### [02 | Java内存模型：看Java如何解决可见性和有序性问题](https://time.geekbang.org/column/article/84017)

> 笔记

* java内存模型
    * JMM是JVM兼容不同的CPU架构的基础。为了屏蔽底层硬件的差异，向开发者提供统一的接口，故诞生了JMM
    * **JMM只是规范**，**JMM只是规范**，**JMM只是规范**
    * JVM对JMM的实现，才是常见的堆、栈、方法区等一些耳熟能详的名词
* 可见性、有序性的根本解决方案
    * 程序员：对CPU缓存、编译器等按需禁用缓存以及编译优化
        * 方法：volatile/synchronized/final
            * 以上三种方法是java提供给程序员“按需”禁止缓存及编译优化的手段。
    * JVM：happens-before原则
    在JVM可预见的场景中禁止CPU缓存、编译器优化
        * 程序次序规则
            * 在一个线程中，前面的操作总是对后面操作可见
        * 锁定规则
            * 一个unlock操作先行发生于后面对这个锁的lock操作（先释放，才能加锁）        
        * 传递性规则
            * **A happens-before B B happens-before C 则 A happens-before C** （以前理解不到位）
            ```java
            class VolatileExample {
              int x = 0;
              volatile boolean v = false;
              public void writer() {
                x = 42;
                v = true;
              }
              public void reader() {
                if (v == true) {
                  // 这里x会是多少呢？
                }
              }
            }
            ```
        * 线程start规则
            * start前的操作，总是对被start的操作可见。它是指主线程 A 启动子线程 B 后，子线程 B 能够看到主线程在启动子线程 B 前的操作。
            ```java
            Thread B = new Thread(()->{
              // 主线程调用B.start()之前
              // 所有对共享变量的修改，此处皆可见
              // 此例中，var==77
            });
            // 此处对共享变量var修改
            var = 77;
            // 主线程启动子线程
            B.start();
            ```
        * 线程 join() 规则
            * 这条是关于线程等待的。它是指主线程 A 等待子线程 B 完成（主线程 A 通过调用子线程 B 的 join() 方法实现），
            当子线程 B 完成后（主线程 A 中 join() 方法返回），主线程能够看到子线程的操作。当然所谓的“看到”，指的是对共享变量的操作。
            ```java
            Thread B = new Thread(()->{
              // 此处对共享变量var修改
              var = 66;
            });
            // 例如此处对共享变量修改，
            // 则这个修改结果对线程B可见
            // 主线程启动子线程
            B.start();
            B.join()
            // 子线程所有对共享变量的修改
            // 在主线程调用B.join()之后皆可见
            // 此例中，var==66
            ```

> 理解

* 文中的禁用CPU缓存，更深层次的理解见
    * store buffer
    * Invalidate Queue
* volatile/synchronized/final等是java提供给程序员禁止指令重排和禁用缓存的工具
    * CPU为了提高利用率需要指令重排，但是在一些场景中指令重排会导致一些意想不到的错误。这时候需要程序员来发现问题并给出了解决问题的手段
* 重点理解JMM是一种规范、不能混淆JVM对JMM的实现     

#### [03 | 互斥锁（上）：解决原子性问题](https://time.geekbang.org/column/article/84344)

> 笔记

* 原子性问题到底该如何解决呢
    * 原子性问题的源头是线程切换，如果能够禁用线程切换那不就能解决这个问题了吗？而操作系统做线程切换是依赖 CPU 中断的，所以禁止 CPU 发生中断就能够禁止线程切换。
    * 同一时刻只有一个线程执行”这个条件非常重要，我们称之为互斥。如果我们能够保证对共享变量的修改是互斥的，那么，无论是单核 CPU 还是多核 CPU，就都能保证原子性了。
* synchronized
    * synchronized属于重量级锁，性能不高，在锁竞争激烈的场所不建议使用
    * synchronized好处在于简单易用，绝对不会unlock
* 锁和受保护资源的关系
    * 受保护资源和锁之间的关联关系是 N:1 的关系

> 重点

* synchronized锁膨胀过程
* synchronized 对象头 monitor
* long类型的并发读写问题（long64位 -- 32位操作系统）

> 金句

单核时代通过控制线程的切花就可以保证原子性，但是在多核时代，单纯的控制线程切换是无法保证原子性的，需要通过锁的互斥来
保证高并发场景下的原子性。

#### [04 | 互斥锁（下）：如何用一把锁保护多个资源](https://time.geekbang.org/column/article/84601)

> 笔记

* 保护没有关联关系的多个资源
    * 用不同的锁对受保护资源进行精细化管理，能够提升性能。这种锁还有个名字，叫细粒度锁
* 保护有关联关系的多个资源
    * 锁能覆盖所有受保护资源
    * 对象锁无法解决这个问题，因为会产生，我家的锁锁住别人家的资源的情况
    * 正确姿势是采用**类锁**（性能有待优化）

> 理解

* 以前没考虑过也没遇到过 同一把锁管理多个资源的情况，以后在用锁的场景需要注意。


#### [05 | 一不小心就死锁了，怎么办](https://time.geekbang.org/column/article/85001)

>笔记

* 死锁的专业定义
    一组线程因为竞争共享资源而陷入互相等待，导致“永久”阻塞的现象。
    ```java
    class Account {
      private int balance;
      // 转账
      void transfer(Account target, int amt){
        // 锁定转出账户
        synchronized(this){     //①
          // 锁定转入账户
          synchronized(target){ //②
            if (this.balance > amt) {
              this.balance -= amt;
              target.balance += amt;
            }
          }
        }
      } 
    }
    ```
* 在现实中寻找答案
    我们试想在古代，没有信息化，账户的存在形式真的就是一个账本，而且每个账户都有一个账本，这些账本都统一存放在文件架上。银行柜员在给我们做转账时，要去文件架上把转出账本和转入账本都拿到手，然后做转账
    * 文件架上恰好有转出账本和转入账本，那就同时拿走；
    * 如果文件架上只有转出账本和转入账本之一，那这个柜员就先把文件架上有的账本拿到手，同时等着其他柜员把另外一个账本送回来；
    * 转出账本和转入账本都没有，那这个柜员就等着两个账本都被送回来。
    死锁产生
    同一时刻A柜员拿到了入账账本，B柜员拿到了出账账本，A等待出账账本，B等待入账账本。AB柜员就会陷入“永久”等待。这就是死锁。
* 粗粒度锁
    解决上述问题，可以采用粗粒度锁，也就是类锁，但是类锁带来的是性能问题。
* 细粒度锁
    * 优点：使用细粒度锁可以提高并行度，是性能优化的有效手段。
    * 风险：机会和风险是并存的。细粒度锁可能导致死锁。
* 如何预防死锁
    解决死锁最好的办法是预防死锁，将其扼杀在摇篮里。
    * 产生死锁的四个条件
        * 互斥，共享资源X和Y只能被一个线程占用
        * 占有且等待，线程T1占有X资源，在等待资源Y的同时，不释放资源X。
        * 不可抢占，其他线程不能强行抢占线程T1占有的资源
        * 循环等待，线程T1等待线程T2占有的资源，线程T2等待线程T1占有的资源，就是循环等待
    * 解决死锁的思路就很简单了，就是破坏以上一个条件就不会造成死锁
        * 破坏占用且等待条件：一次性申请所有的资源
            * example：不允许柜员直接在文件架上拿账本，而是增加管理员，柜员拿账本需要通过管理员来审核。比如，A柜员需要拿进账
            管理员发现文件架上没有出账账本，所以不允许柜员只拿进账账本。这样就解决了占用且等待问题。
        * 破坏不可抢占条件：核心是要能够主动释放它占有的资源
            * 这一点 synchronized 是做不到的。因为synchronized一旦申请不到资源就会进入阻塞状态
        进入阻塞态就以为什么也干不了，也释放不了线程占用的资源。
            * ReetrentLock 可以解决这个问题
        * 破坏循环等待条件：对资源排序，然后按序申请资源
            * 我们假设每个账户都有不同的属性 id，这个 id 可以作为排序字段，申请的时候，我们可以按照从小到大的顺序来申请
            ```java
            class Account {
              private int id;
              private int balance;
              // 转账
              void transfer(Account target, int amt){
                Account left = this;        //①
                Account right = target;    //②
                if (this.id > target.id) { //③
                  left = target;           //④
                  right = this;            //⑤
                }                          //⑥
                // 锁定序号小的账户
                synchronized(left){
                  // 锁定序号大的账户
                  synchronized(right){ 
                    if (this.balance > amt){
                      this.balance -= amt;
                      target.balance += amt;
                    }
                  }
                }
              } 
            }
            ```

> 金句

当我们在编程世界里遇到问题时，应不局限于当下，可以换个思路，向现实世界要答案，利用现实世界的模型来构思解决方案，
这样往往能够让我们的方案更容易理解，也更能够看清楚问题的本质。

用细粒度锁来锁定多个资源时，要注意死锁的问题。这个就需要你能把它强化为一个思维定势，遇到这种场景，
马上想到可能存在死锁问题。当你知道风险之后，才有机会谈如何预防和避免，因此，识别出风险很重要

我们在选择具体方案的时候，还需要评估一下操作成本，从中选择一个成本最低的方案。

> 收获

while(true)循环是不是应该有个timeout，避免一直阻塞下去？
加超时在项目中非常实用。

