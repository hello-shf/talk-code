#### [01 | 如何学习Linux性能优化？](https://time.geekbang.org/column/article/69346)

> 笔记

* 性能指标
![性能指标.png](https://github.com/hello-shf/talk-code/blob/master/images/性能指标.png?raw=true)
* 技术路线
![技术路线.png](https://github.com/hello-shf/talk-code/blob/master/images/技术路线.png?raw=true)
* 怎么学更高效？
    * 虽然系统的原理很重要，但在刚开始一定不要试图抓住所有的实现细节。
    * 边学边实践，通过大量的案例演习掌握 Linux 性能的分析和优化。
    * 勤思考，多反思，善总结，多问为什么。


#### [02 | 基础篇：到底应该怎么理解“平均负载”？](https://time.geekbang.org/column/article/69618)

> 笔记

* 平均负载
    * 平均负载是指单位时间内，系统处于可运行状态和不可中断状态的平均进程数，也就是平均活跃进程数，它和 CPU 使用率并没有直接关系。
        * 可运行状态
            * 所谓可运行状态的进程，是指正在使用 CPU 或者正在等待 CPU 的进程，也就是我们常用 ps 命令看到的，处于 R 状态（Running 或 Runnable）的进程
        * 不可中断状态
            * 不可中断状态的进程则是正处于内核态关键流程中的进程，并且这些流程是不可打断的，比如最常见的是等待硬件设备的 I/O 响应，也就是我们在 ps 命令中看到的 D 状态（Uninterruptible Sleep，也称为 Disk Sleep）的进程。
* $ uptime

| 当前时间 | 系统运行时间 | 当前用户数 | 过去1分钟 | 过去5分钟 | 过去15分钟 |
| :---: | :---: | :----: | :---: | :---: | :---: |
| 02:34:03 up 2 days | 20:14 | 1 user | load average: 0.63 | 0.83 | 0.88 |

* 平均负载为多少时合理？
    * 首先需要知道有多少 CPU
        * lscpu |grep CPU
        * grep 'model name' /proc/cpuinfo | wc -l
    * 如果 1 分钟、5 分钟、15 分钟的三个值基本相同，或者相差不大，那就说明系统负载很平稳。
    * 但如果 1 分钟的值远小于 15 分钟的值，就说明系统最近 1 分钟的负载在减少，而过去 15 分钟内却有很大的负载。
    * 如果 1 分钟的值远大于 15 分钟的值，就说明最近 1 分钟的负载在增加，这种增加有可能只是临时性的，也有可能还会持续增加下去，所以就需要持续观察。一旦 1 分钟的平均负载接近或超过了 CPU 的个数，就意味着系统正在发生过载的问题，这时就得分析调查是哪里导致的问题，并要想办法优化了。
这里我再举个例子，假设我们在一个单 CPU 系统上看到平均负载为 1.73，0.60，7.98，那么说明在过去 1 分钟内，系统有 73% 的超载，而在 15 分钟内，有 698% 的超载，从整体趋势来看，系统的负载在降低。
    * 经验值 ：当平均负载高于 CPU 数量 **70%** 的时候
* 平均负载 & CPU 使用率
    * 区别
        * CPU使用率：指的是 正在使用CPU的进程。
        * 平均负载：正在使用CPU + 正在等待CPU + 正在等待 I/O的进程
    * 两者并不能完全对应
        * **CPU 密集型进程** 一致，使用大量 CPU 会导致平均负载升高
        * **I/O 密集型进程** 不一致，等待 I/O 也会导致平均负载升高，但 CPU 使用率不一定很高；
        * 大量等待 CPU 的进程调度也会导致平均负载升高，此时的 CPU 使用率也会比较高
* 安装 stress & sysstat 进行实操
    * stress 是一个 Linux 系统压力测试工具，这里我们用作异常进程模拟平均负载升高的场景
    * sysstat 包含了常用的 Linux 性能工具，用来监控和分析系统的性能。我们的案例会用到这个包的两个命令 mpstat 和 pidstat。
        * mpstat 是一个常用的多核 CPU 性能分析工具，用来实时查看每个 CPU 的性能指标，以及所有 CPU 的平均指标。
        * pidstat 是一个常用的进程性能分析工具，用来实时查看进程的 CPU、内存、I/O 以及上下文切换等性能指标。
        
        
#### [03 | 基础篇：经常说的 CPU 上下文切换是什么意思？（上）](https://time.geekbang.org/column/article/69859)

> 笔记

* 几个名词
    * CPU上下文：CPU必须依赖的环境被称为CPU上下文，包括
        * **CPU寄存器**：CPU内置的容量小，速度极快的内存。**CPU用来存储指令集的寄存器**
        * **程序计数器**：**用来存储CPU正在执行的指令位置、或者即将执行的下一条指令的位置的寄存器**
    * 进程：系统资源分配的最小单位
    * 线程：CPU运算调度的最小单位
    > 换一句话说：线程是调度的基本单位，而进程则是资源拥有的基本单位
* 系统(CPU)两种状态
    * 内核态：具有最高权限，可以访问所有资源
    * 用户态: 只能访问受限的资源，不能直接访问内存等硬件设备，必须通过系统调用陷入到内核中，才能访问这些受限的资源
* 从进程的角度理解内核态和用户态
    * 进程既可以在内核空间运行，也可以在用户空间运行
    * 系统调用：进程 用户态 --> 内核态 的转变需要系统调用来完成。PS：可以这么理解系统调用属于同进程内的上线文切换。系统调用过程通常称为特权模式切换，而不是上下文切换。
     另外注意一点，系统调用也是避免不了上下文切换的。
     * **进程的切换只能发生在内核态** 也就是说系统调用只能发生在内核态
* 系统调用 同 CPU上线文切换的区别
    * 系统调用过程中一直是同一个进程在运行。
    * 进程上下文切换，是指从一个进程切换到另一个进程运行。
    * CPU上下文切换过程
        * 进程1用户态 -- > 进程1内核态 **TODO**
* 触发进程上下文切换的场景
    * 正常轮换：根据调度策略，将CPU时间划片为对应的时间片，当时间片耗尽，当前进程必须挂起。
    * 资源不足：进程资源未就绪，在进程所需要的资源未准备就绪时，进程将被挂起。系统调度其它进程运行
    * 主动挂起：进程sleep，进程挂起
    * 被迫挂起：当有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行。
    * 硬件中断：发生硬件中断时，CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序。
* CPU上下文切换过程
    * 记录当前任务的上下文(即寄存器和计算器等所有的状态)；
    * 找到新任务的上下文并加载；
    * 切换到新任务的程序计算器位置，恢复其任务。
* CPU上下文切换的三个不同维度
    * 进程上下文切换：进程上下文切换是指从一个进程切换到另一个进程
        * 进程上下文切换的过程
            * 接收到切换信号，挂起进程，记录当前进程的虚拟内存、栈等资源存储;
            * 将这个进程在 CPU 中的上下文状态存储于起来;
            * 然后在内存中检索下一个进程的上下文;
            * 并将其加载到 CPU的寄存器中恢复;
            * 还需要刷新进程的虚拟内存和用户栈;
            * 最后跳转到程序计数器所指向的位置（即跳转到进程被中断时的代码行），以恢复该进程。
    * 线程上线文切换
        * 第一种情况：当两个线程不是同一个进程，则线程上下文切换同进程上下文切换。
        * 第二种情况：当两个线程同属一个进程，进程内的虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动。只需要切换线程的私有数据和寄存器等不共享的数据。
    * 中断上下文切换
        * 快速响应硬件的事件，中断处理会打断进程的正常调度和执行。同一CPU内，硬件中断优先级高于进程。切换过程类似于系统调用的时候，不涉及到用户运行态资源。但大量的中断上下文切换同样可能引发性能问题。
* 线程和进程的区别
    * **线程是调度的基本单位，而进程则是资源拥有的基本单位**
    * 当进程只有一个线程时，可以认为进程就等于线程。
    * 当进程拥有多个线程时，这些线程会共享相同的虚拟内存和全局变量等资源。这些资源在上下文切换时是不需要修改的。
    * 另外，线程也有自己的私有数据，比如栈和寄存器等，这些在上下文切换时也是需要保存的。

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
